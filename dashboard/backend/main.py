import requests
import os
import random
import string
from datetime import datetime, timedelta
from collections import defaultdict

from fastapi import FastAPI, HTTPException
from fastapi.staticfiles import StaticFiles
from fastapi.responses import FileResponse, JSONResponse
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from supabase import create_client, Client
from dotenv import load_dotenv

# --- SETUP & CONFIGURATION ---
load_dotenv()

app = FastAPI()

# Middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Mount Static Files (Frontend)
app.mount("/static", StaticFiles(directory="static"), name="static")

# Supabase & API Keys
supabase_url = os.getenv("SUPABASE_URL")
supabase_key = os.getenv("SUPABASE_KEY")
supabase: Client = create_client(supabase_url, supabase_key)
WEATHER_API_KEY = os.getenv("WEATHER_API_KEY")

# --- DATA MODELS ---
class SensorData(BaseModel):
    mac_address: str
    temperature: float = None
    humidity: float = None
    soil_moisture: float = None
    ph_value: float = None
    rain_value: float = None
    electrical_conductivity: float = None
    nitrogen: float = None
    phosphorus: float = None
    potassium: float = None

class DeviceRegister(BaseModel):
    mac_address: str
    mac_key: str  # Generated by ESP32

class DeviceVerifyByKey(BaseModel):
    mac_key: str

class UserDeviceLink(BaseModel):
    user_id: str
    mac_address: str
    device_name: str = None

# ==========================================
#      SECTION 1: HARDWARE & DEVICE API
# ==========================================

# --- 1. DEVICE SELF-REGISTRATION ---
# Called by ESP32 on boot to register itself or update its key
@app.post("/api/register-device")
async def register_device(data: DeviceRegister):
    try:
        # Check if device exists
        exists = supabase.table("device_registry").select("*").eq("mac_address", data.mac_address).execute()
        
        if not exists.data:
            # Register new device. Status 0 (Inactive) until User claims it.
            supabase.table("device_registry").insert({
                "mac_address": data.mac_address,
                "mac_key": data.mac_key,
                "status_indicator": 0 
            }).execute()
            
            print(f"ðŸ†• Device Registered: {data.mac_address} | Key: {data.mac_key}")
            return {"status": "registered"}
        else:
            # Update last_seen and Key (in case of reset)
            supabase.table("device_registry").update({
                "last_seen": "now()",
                "mac_key": data.mac_key 
            }).eq("mac_address", data.mac_address).execute()
            
            print(f"ðŸ”„ Device Reconnected: {data.mac_address}")
            return {"status": "existing"}

    except Exception as e:
        return JSONResponse(status_code=500, content={"error": str(e)})

# --- 2. VERIFY KEY (Frontend) ---
# Called by the Web App when user types in the Key to claim a device
@app.post("/api/verify-device-key")
async def verify_device_key(data: DeviceVerifyByKey):
    try:
        # A. Find Device by Key
        registry = supabase.table("device_registry").select("*").eq("mac_key", data.mac_key).execute()
        
        if not registry.data:
            return JSONResponse(status_code=404, content={"message": "Invalid Key. Device not found."})

        device_info = registry.data[0]
        mac_address = device_info['mac_address']

        # B. Check if already linked - try user_devices table first, then profiles
        try:
            existing_link = supabase.table("user_devices").select("*").eq("mac_address", mac_address).execute()
            if existing_link.data:
                return JSONResponse(status_code=409, content={"message": "Device already linked to another user."})
        except Exception:
            # Fallback to profiles table
            owner = supabase.table("profiles").select("*").eq("mac_address", mac_address).execute()
            if owner.data:
                return JSONResponse(status_code=409, content={"message": "Device already linked to another user."})

        # C. Activate Device (Set Status = 1)
        supabase.table("device_registry").update({"status_indicator": 1}).eq("mac_address", mac_address).execute()

        # D. Return MAC to Frontend (so Frontend can link it to the User via user_devices table)
        return {
            "message": "Device verified & activated", 
            "status": "available", 
            "mac_address": mac_address 
        }

    except Exception as e:
        return JSONResponse(status_code=500, content={"error": str(e)})

# --- 3. HARDWARE LOGGING ---
# Called by ESP32 to send sensor data
@app.post("/api/hardware-log")
async def log_hardware_data(data: SensorData):
    try:
        # 1. Check Status in Registry
        device_check = supabase.table("device_registry").select("status_indicator").eq("mac_address", data.mac_address).execute()
        
        if not device_check.data:
            return JSONResponse(status_code=404, content={"message": "Device not registered"})
            
        status = device_check.data[0]['status_indicator']
        
        # 2. STATUS CHECK: If 0, Reject Data (Save DB space)
        if status == 0:
            print(f"ðŸ’¤ Ignored Data from {data.mac_address} (Status: Inactive)")
            return JSONResponse(status_code=403, content={"message": "Device is inactive (Link it in Dashboard)"})

        # 3. Find Owner via user_devices table first, then fallback to profiles
        user_id = None
        try:
            owner = supabase.table("user_devices").select("user_id").eq("mac_address", data.mac_address).execute()
            if owner.data:
                user_id = owner.data[0]['user_id']
        except Exception:
            pass
        
        # Fallback to profiles table
        if not user_id:
            owner = supabase.table("profiles").select("id").eq("mac_address", data.mac_address).execute()
            if owner.data:
                user_id = owner.data[0]['id']
        
        if not user_id:
            print(f"âš ï¸ Device {data.mac_address} has no owner.")
            return JSONResponse(status_code=403, content={"message": "Unclaimed device"})
        
        payload = {
            "user_id": user_id,
            "mac_address": data.mac_address,
            "temperature": data.temperature,
            "humidity": data.humidity,
            "soil_moisture": data.soil_moisture,
            "ph_value": data.ph_value,
            "rain_value": data.rain_value,
            "electrical_conductivity": data.electrical_conductivity,
            "nitrogen": data.nitrogen,
            "phosphorus": data.phosphorus,
            "potassium": data.potassium
        }
        
        print(f"ðŸ“¦ Logging Data for User {user_id}: {payload}")
        
        supabase.table("sensor_data").insert(payload).execute()
        return {"message": "Logged"}

    except Exception as e:
        print(f"ðŸ”¥ LOG ERROR: {e}")
        return JSONResponse(status_code=500, content={"error": str(e)})


# ==========================================
#      SECTION 2: WEB FRONTEND ROUTES
# ==========================================

@app.get("/")
async def read_root(): return FileResponse('static/login.html')

@app.get("/signup")
async def read_signup(): return FileResponse('static/signup.html')

@app.get("/setup-hardware")
async def read_setup(): return FileResponse('static/setup_hardware.html')

@app.get("/dashboard")
async def read_dashboard(): return FileResponse('static/dashboard.html')

@app.get("/prediction")
async def read_prediction(): return FileResponse('static/prediction.html')

@app.get("/forgot-password")
async def read_forgot_password(): return FileResponse('static/forgot_password.html')

@app.get("/reset-password")
async def read_reset_password(): return FileResponse('static/reset_password.html')


# ==========================================
#      SECTION 3: WEATHER & FORECAST
# ==========================================

@app.get("/weather")
def get_weather():
    try:
        # Defaulting to Kotagiri for this project
        url = f"https://api.openweathermap.org/data/2.5/weather?q=Kotagiri,IN&appid={WEATHER_API_KEY}&units=metric"
        response = requests.get(url)
        data = response.json()
        if response.status_code != 200: raise HTTPException(status_code=500)
        
        frontend_data = {
            "location": data["name"],
            "temperature_celsius": round(data["main"]["temp"], 1),
            "condition": data["weather"][0]["description"].title(),
            "rain_probability": data.get("clouds", {}).get("all", 0),
            "humidity_percent": data["main"]["humidity"],
            "wind_kph": round(data["wind"]["speed"] * 3.6, 1),
            "day": datetime.now().strftime("%A"),
            "date": datetime.now().strftime("%d %B %Y")
        }
        
        # Log weather snapshot to DB for future ML training
        try:
            supabase.table("weather_log").insert({
                "location": frontend_data["location"],
                "temperature_celsius": frontend_data["temperature_celsius"],
                "condition": frontend_data["condition"],
                "rain_probability": frontend_data["rain_probability"],
                "humidity_percent": frontend_data["humidity_percent"],
                "wind_kph": frontend_data["wind_kph"]
            }).execute()
        except Exception as db_err:
            print(f"âš ï¸ Weather DB Log failed: {db_err}")
            
        return frontend_data
    except Exception as e: 
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/forecast")
def get_forecast():
    try:
        # Coordinates for Kotagiri
        lat, lon = 11.42, 76.87
        url = f"https://api.openweathermap.org/data/2.5/forecast?lat={lat}&lon={lon}&units=metric&appid={WEATHER_API_KEY}"
        
        response = requests.get(url)
        data = response.json()

        if response.status_code != 200:
            raise HTTPException(status_code=response.status_code, detail=data)

        # --- 1. Process & INTERPOLATE Hourly Data (Smoother Graphs) ---
        raw_list = data["list"][:17] # Get enough points to cover 48 hours
        hourly_interpolated = []

        for i in range(len(raw_list) - 1):
            start = raw_list[i]
            end = raw_list[i+1]

            # Create 3 hourly points between the 3-hour gaps provided by API
            for hour_offset in range(3):
                factor = hour_offset / 3.0
                
                t_start = datetime.utcfromtimestamp(start["dt"])
                t_current = t_start + timedelta(hours=hour_offset)
                
                # Linear interpolation for smooth data
                temp = start["main"]["temp"] + (end["main"]["temp"] - start["main"]["temp"]) * factor
                pop = start.get("pop", 0) + (end.get("pop", 0) - start.get("pop", 0)) * factor
                wind = start["wind"]["speed"] + (end["wind"]["speed"] - start["wind"]["speed"]) * factor

                # Rain Volume approximation
                rain_vol_start = start.get("rain", {}).get("3h", 0) / 3.0
                rain_vol_end = end.get("rain", {}).get("3h", 0) / 3.0
                rain_vol = rain_vol_start + (rain_vol_end - rain_vol_start) * factor

                hourly_interpolated.append({
                    "time": t_current.strftime("%I %p").lstrip('0').lower(), 
                    "day": t_current.strftime("%a"),
                    "temp": round(temp, 1),
                    "rain_prob": int(pop * 100),
                    "rain_mm": round(rain_vol, 2),
                    "wind": round(wind, 1),
                    "condition": start["weather"][0]["description"].replace(" ", "\n"),
                    "icon": start["weather"][0]["icon"]
                })
                
                if len(hourly_interpolated) >= 48:
                    break
            if len(hourly_interpolated) >= 48:
                break

        # --- 2. Daily Aggregation ---
        daily_agg = defaultdict(lambda: {
            "temps": [], "humidities": [], "pressures": [], "winds": [], "rain_sum": 0,
            "weather_ids": [], "icon": None, "desc": None, "day_name": None, "date_full": None,
            "parts": {"morn": [], "after": [], "eve": [], "night": []}
        })
        
        # Get dynamic sunrise/sunset
        sunrise = datetime.utcfromtimestamp(data["city"]["sunrise"]).strftime("%H:%M")
        sunset = datetime.utcfromtimestamp(data["city"]["sunset"]).strftime("%H:%M")

        for entry in data["list"]:
            date_obj = datetime.utcfromtimestamp(entry["dt"])
            date_str = date_obj.strftime("%Y-%m-%d")
            hour = date_obj.hour
            
            if not daily_agg[date_str]["day_name"]:
                daily_agg[date_str]["day_name"] = date_obj.strftime("%a, %b %d")
                daily_agg[date_str]["date_full"] = date_str
            
            daily_agg[date_str]["temps"].append(entry["main"]["temp"])
            daily_agg[date_str]["humidities"].append(entry["main"]["humidity"])
            daily_agg[date_str]["pressures"].append(entry["main"]["pressure"])
            daily_agg[date_str]["winds"].append(entry["wind"]["speed"])
            if "rain" in entry and "3h" in entry["rain"]:
                daily_agg[date_str]["rain_sum"] += entry["rain"]["3h"]
            
            # Pick the weather icon from the middle of the day (noon)
            if hour >= 12 and daily_agg[date_str]["icon"] is None:
                daily_agg[date_str]["icon"] = entry["weather"][0]["icon"]
                daily_agg[date_str]["desc"] = entry["weather"][0]["description"].title()

            # Bucketing for Morning/Afternoon/Evening/Night
            if 6 <= hour < 12: daily_agg[date_str]["parts"]["morn"].append(entry["main"]["temp"])
            elif 12 <= hour < 17: daily_agg[date_str]["parts"]["after"].append(entry["main"]["temp"])
            elif 17 <= hour < 21: daily_agg[date_str]["parts"]["eve"].append(entry["main"]["temp"])
            else: daily_agg[date_str]["parts"]["night"].append(entry["main"]["temp"])

        daily_forecast = []
        for date_key, val in daily_agg.items():
            def avg(lst): return round(sum(lst)/len(lst), 1) if lst else "N/A"
            if not val["icon"]: val["icon"] = "02d"; val["desc"] = "Cloudy"

            daily_forecast.append({
                "date": val["day_name"], 
                "temp_max": round(max(val["temps"])),
                "temp_min": round(min(val["temps"])),
                "rain_total": round(val["rain_sum"], 1),
                "humidity": round(sum(val["humidities"]) / len(val["humidities"])),
                "wind": round(sum(val["winds"]) / len(val["winds"]), 1),
                "pressure": round(sum(val["pressures"]) / len(val["pressures"])),
                "icon": val["icon"],
                "description": val["desc"],
                "sunrise": sunrise,
                "sunset": sunset,
                "morn": avg(val["parts"]["morn"]),
                "after": avg(val["parts"]["after"]),
                "eve": avg(val["parts"]["eve"]),
                "night": avg(val["parts"]["night"])
            })

        return {
            "daily": daily_forecast,
            "hourly": hourly_interpolated 
        }

    except Exception as e:
        print("âŒ FORECAST ERROR:", e)
        raise HTTPException(status_code=500, detail=str(e))


# ==========================================
#      SECTION 4: MULTI-DEVICE MANAGEMENT
# ==========================================

# --- Get All Devices for a User ---
@app.get("/api/user-devices/{user_id}")
async def get_user_devices(user_id: str):
    try:
        # Try to get devices from user_devices table
        try:
            devices = supabase.table("user_devices").select("*").eq("user_id", user_id).execute()
            if devices.data:
                return {"devices": devices.data}
        except Exception as table_err:
            print(f"âš ï¸ user_devices table not found or error: {table_err}")
        
        # Fallback: Check profiles table for backward compatibility
        profile = supabase.table("profiles").select("mac_address").eq("id", user_id).execute()
        if profile.data and profile.data[0].get('mac_address'):
            # Return the mac_address from profiles as a single device
            return {"devices": [{
                "id": 0,
                "user_id": user_id,
                "mac_address": profile.data[0]['mac_address'],
                "device_name": "Device 1"
            }]}
        
        return {"devices": []}
    except Exception as e:
        print(f"âŒ GET USER DEVICES ERROR: {e}")
        return JSONResponse(status_code=500, content={"error": str(e)})

# --- Link Device to User (called from setup_hardware) ---
@app.post("/api/link-device")
async def link_device(data: UserDeviceLink):
    print(f"ðŸ“± LINK DEVICE REQUEST: user_id={data.user_id}, mac={data.mac_address}, name={data.device_name}")
    try:
        device_name = data.device_name if data.device_name else "Device 1"
        use_new_table = True
        
        # Try to use user_devices table first
        try:
            # Check if device is already linked to this user
            existing = supabase.table("user_devices").select("*").eq("user_id", data.user_id).eq("mac_address", data.mac_address).execute()
            if existing.data:
                return JSONResponse(status_code=409, content={"message": "Device already linked to your account."})
            
            # Check if device is linked to another user
            other_owner = supabase.table("user_devices").select("*").eq("mac_address", data.mac_address).execute()
            if other_owner.data:
                return JSONResponse(status_code=409, content={"message": "Device already linked to another user."})
            
            # Count existing devices to set a default name
            user_devices = supabase.table("user_devices").select("id").eq("user_id", data.user_id).execute()
            device_count = len(user_devices.data) if user_devices.data else 0
            device_name = data.device_name if data.device_name else f"Device {device_count + 1}"
            
            # Insert new device link
            supabase.table("user_devices").insert({
                "user_id": data.user_id,
                "mac_address": data.mac_address,
                "device_name": device_name
            }).execute()
            
        except Exception as table_err:
            print(f"âš ï¸ user_devices table not available, using profiles fallback: {table_err}")
            use_new_table = False
        
        # Always update profiles table for backward compatibility
        profile = supabase.table("profiles").select("mac_address").eq("id", data.user_id).execute()
        if profile.data:
            current_mac = profile.data[0].get('mac_address')
            # If no mac_address set, or if user_devices table is not available
            if not current_mac or not use_new_table:
                supabase.table("profiles").update({"mac_address": data.mac_address}).eq("id", data.user_id).execute()
        
        return {"message": "Device linked successfully", "device_name": device_name}
    except Exception as e:
        print(f"âŒ LINK DEVICE ERROR: {e}")
        return JSONResponse(status_code=500, content={"error": str(e)})

# --- Update Device Name ---
@app.put("/api/user-devices/{device_id}")
async def update_device_name(device_id: int, device_name: str):
    try:
        supabase.table("user_devices").update({"device_name": device_name}).eq("id", device_id).execute()
        return {"message": "Device name updated"}
    except Exception as e:
        return JSONResponse(status_code=500, content={"error": str(e)})

# --- Remove Device from User ---
@app.delete("/api/user-devices/{device_id}")
async def remove_user_device(device_id: int):
    try:
        # Get device info before deleting
        device = supabase.table("user_devices").select("*").eq("id", device_id).execute()
        if device.data:
            mac_address = device.data[0]['mac_address']
            # Set device status back to inactive
            supabase.table("device_registry").update({"status_indicator": 0}).eq("mac_address", mac_address).execute()
        
        # Remove link
        supabase.table("user_devices").delete().eq("id", device_id).execute()
        return {"message": "Device removed"}
    except Exception as e:
        return JSONResponse(status_code=500, content={"error": str(e)})

# --- Get Sensor Data for Specific Device ---
@app.get("/api/sensor-data/{user_id}/{mac_address}")
async def get_sensor_data_for_device(user_id: str, mac_address: str):
    try:
        data = supabase.table("sensor_data").select("*").eq("user_id", user_id).eq("mac_address", mac_address).order("created_at", desc=True).limit(1).execute()
        return {"data": data.data[0] if data.data else None}
    except Exception as e:
        return JSONResponse(status_code=500, content={"error": str(e)})
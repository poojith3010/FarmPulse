<!DOCTYPE html>
<html lang="en" class="dark">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>Forgot Password - FarmPulse</title>
  
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  
  <link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@300;400;500;600&family=Space+Grotesk:wght@500;700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <script src="/static/js/app.js"></script>
  
  <style>
    /* 1. VIEWPORT FIXES */
    html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%; /* Fallback */
        height: 100dvh; /* Dynamic viewport height */
        background-color: #000 !important;
        overflow: hidden;
    }

    /* 2. BACKGROUND CANVAS */
    #canvas-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 0;
        pointer-events: none;
    }

    /* 3. CONTENT LAYER */
    #content-layer {
        position: relative;
        z-index: 10;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        pointer-events: none;
        padding-bottom: 5vh; /* Visual balance */
    }
    #content-layer > * { pointer-events: auto; }

    /* Glass UI */
    .glass-card { 
        background: rgba(0, 0, 0, 0.4); 
        backdrop-filter: blur(20px); 
        -webkit-backdrop-filter: blur(20px);
        border: 1px solid rgba(255, 255, 255, 0.1); 
        box-shadow: 0 0 40px rgba(16, 185, 129, 0.1);
    }
    .form-input { 
        background: rgba(0, 0, 0, 0.5); 
        border: 1px solid rgba(255, 255, 255, 0.1); 
        color: white; 
        transition: all 0.3s;
    }
    .form-input:focus { outline: none; border-color: #10b981; background: rgba(0,0,0,0.7); }
    
    @keyframes fadeInUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
    .animate-up { animation: fadeInUp 0.8s cubic-bezier(0.2, 0.8, 0.2, 1) forwards; opacity: 0; }
    .delay-1 { animation-delay: 0.1s; } .delay-2 { animation-delay: 0.2s; } .delay-3 { animation-delay: 0.3s; }
  </style>
</head>
<body class="text-white">

  <div id="canvas-container"></div>

  <div id="content-layer" class="p-6">
    <div class="w-full max-w-sm text-center">
      <h1 class="text-4xl font-bold text-white mb-2 font-headings animate-up">Forgot Password</h1>
      <p class="text-gray-400 mb-8 animate-up delay-1">Enter your email to get a reset link.</p>
      
      <div class="glass-card rounded-2xl p-6 animate-up delay-2 text-left">
        <div class="space-y-4">
          <input id="resetEmail" type="email" placeholder="Email Address" class="w-full p-3 form-input rounded-lg" />
          <button id="sendResetBtn" class="w-full bg-emerald-600 hover:bg-emerald-500 text-white p-3 rounded-lg font-bold uppercase tracking-wide transition-all hover:scale-[1.02] shadow-[0_0_20px_rgba(16,185,129,0.4)] mt-4">Send Reset Link</button>
          <a href="/" class="block text-center text-xs mt-4 text-emerald-400 font-bold hover:text-emerald-300 transition-colors">Back to Login</a>
        </div>
      </div>
    </div>
  </div>

  <script>
    (function() {
        const isMobile = window.innerWidth < 768;

        const config = {
            colors: ["#ff5c7a", "#8a5cff", "#00ffd1"],
            rotation: 30,
            speed: 0.3,
            scale: isMobile ? 0.6 : 1.2,
            frequency: 1.4,
            warpStrength: 1.2,
            mouseInfluence: isMobile ? 0.3 : 0.8,
            parallax: 0.6,
            noise: 0.08,
            transparent: false
        };
        const MAX_COLORS = 8;

        const frag = `
        #define MAX_COLORS ${MAX_COLORS}
        uniform vec2 uCanvas;
        uniform float uTime;
        uniform float uSpeed;
        uniform vec2 uRot;
        uniform int uColorCount;
        uniform vec3 uColors[MAX_COLORS];
        uniform int uTransparent;
        uniform float uScale;
        uniform float uFrequency;
        uniform float uWarpStrength;
        uniform vec2 uPointer;
        uniform float uMouseInfluence;
        uniform float uParallax;
        uniform float uNoise;
        varying vec2 vUv;

        void main() {
            float t = uTime * uSpeed;
            vec2 p = vUv * 2.0 - 1.0;
            p += uPointer * uParallax * 0.1;
            vec2 rp = vec2(p.x * uRot.x - p.y * uRot.y, p.x * uRot.y + p.y * uRot.x);
            vec2 q = vec2(rp.x * (uCanvas.x / uCanvas.y), rp.y);
            q /= max(uScale, 0.0001);
            q /= 0.5 + 0.2 * dot(q, q);
            q += 0.2 * cos(t) - 7.56;
            vec2 toward = (uPointer - rp);
            q += toward * uMouseInfluence * 0.2;

            vec3 col = vec3(0.0);
            float a = 1.0;

            if (uColorCount > 0) {
                vec2 s = q;
                vec3 sumCol = vec3(0.0);
                float cover = 0.0;
                for (int i = 0; i < MAX_COLORS; ++i) {
                    if (i >= uColorCount) break;
                    s -= 0.01;
                    vec2 r = sin(1.5 * (s.yx * uFrequency) + 2.0 * cos(s * uFrequency));
                    float m0 = length(r + sin(5.0 * r.y * uFrequency - 3.0 * t + float(i)) / 4.0);
                    float kBelow = clamp(uWarpStrength, 0.0, 1.0);
                    float kMix = pow(kBelow, 0.3);
                    float gain = 1.0 + max(uWarpStrength - 1.0, 0.0);
                    vec2 disp = (r - s) * kBelow;
                    vec2 warped = s + disp * gain;
                    float m1 = length(warped + sin(5.0 * warped.y * uFrequency - 3.0 * t + float(i)) / 4.0);
                    float m = mix(m0, m1, kMix);
                    float w = 1.0 - exp(-6.0 / exp(6.0 * m));
                    sumCol += uColors[i] * w;
                    cover = max(cover, w);
                }
                col = clamp(sumCol, 0.0, 1.0);
                a = uTransparent > 0 ? cover : 1.0;
            }

            if (uNoise > 0.0001) {
                float n = fract(sin(dot(gl_FragCoord.xy + vec2(uTime), vec2(12.9898, 78.233))) * 43758.5453123);
                col += (n - 0.5) * uNoise;
                col = clamp(col, 0.0, 1.0);
            }

            vec3 rgb = (uTransparent > 0) ? col * a : col;
            gl_FragColor = vec4(rgb, a);
        }
        `;

        const vert = `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = vec4(position, 1.0);
        }
        `;

        function initBackground() {
            const container = document.getElementById('canvas-container');
            if(!container) return;

            const scene = new THREE.Scene();
            const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
            const geometry = new THREE.PlaneGeometry(2, 2);

            const uColorsArray = new Array(MAX_COLORS).fill(null).map(() => new THREE.Vector3(0,0,0));
            const toVec3 = (hex) => {
                const h = hex.replace('#', '').trim();
                let r, g, b;
                if (h.length === 3) {
                    r = parseInt(h[0] + h[0], 16); g = parseInt(h[1] + h[1], 16); b = parseInt(h[2] + h[2], 16);
                } else {
                    r = parseInt(h.slice(0, 2), 16); g = parseInt(h.slice(2, 4), 16); b = parseInt(h.slice(4, 6), 16);
                }
                return new THREE.Vector3(r / 255, g / 255, b / 255);
            };

            const activeColors = config.colors.map(toVec3);
            for(let i = 0; i < MAX_COLORS; i++) {
                if(i < activeColors.length) uColorsArray[i].copy(activeColors[i]);
            }

            const material = new THREE.ShaderMaterial({
                vertexShader: vert,
                fragmentShader: frag,
                uniforms: {
                    uCanvas: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                    uTime: { value: 0 },
                    uSpeed: { value: config.speed },
                    uRot: { value: new THREE.Vector2(1, 0) },
                    uColorCount: { value: activeColors.length },
                    uColors: { value: uColorsArray },
                    uTransparent: { value: config.transparent ? 1 : 0 },
                    uScale: { value: config.scale },
                    uFrequency: { value: config.frequency },
                    uWarpStrength: { value: config.warpStrength },
                    uPointer: { value: new THREE.Vector2(0, 0) },
                    uMouseInfluence: { value: config.mouseInfluence },
                    uParallax: { value: config.parallax },
                    uNoise: { value: config.noise }
                },
                transparent: config.transparent
            });

            const mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);

            const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: 'high-performance' });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.innerWidth < 768 ? 1 : Math.min(window.devicePixelRatio || 1, 2));
            renderer.setClearColor(0x000000, 1);
            container.appendChild(renderer.domElement);

            const clock = new THREE.Clock();
            const pointerCurrent = new THREE.Vector2(0,0);
            const pointerTarget = new THREE.Vector2(0,0);
            
            function animate() {
                const dt = clock.getDelta();
                const elapsed = clock.elapsedTime;
                material.uniforms.uTime.value = elapsed;

                const deg = (config.rotation % 360) + (0 * elapsed);
                const rad = (deg * Math.PI) / 180;
                material.uniforms.uRot.value.set(Math.cos(rad), Math.sin(rad));

                pointerCurrent.lerp(pointerTarget, 0.05);
                material.uniforms.uPointer.value.copy(pointerCurrent);

                renderer.render(scene, camera);
                requestAnimationFrame(animate);
            }

            function handleResize() {
                const w = window.innerWidth;
                const h = window.innerHeight;
                renderer.setSize(w, h);
                material.uniforms.uCanvas.value.set(w, h);
                if (w < 768) material.uniforms.uScale.value = 0.6;
                else material.uniforms.uScale.value = 1.2;
            }

            window.addEventListener('resize', handleResize);
            window.addEventListener('mousemove', (e) => {
                const x = ((e.clientX / window.innerWidth) * 2 - 1);
                const y = -((e.clientY / window.innerHeight) * 2 - 1);
                pointerTarget.set(x, y);
            });
            window.addEventListener('touchmove', (e) => {
                if(e.touches.length > 0) {
                    const x = ((e.touches[0].clientX / window.innerWidth) * 2 - 1);
                    const y = -((e.touches[0].clientY / window.innerHeight) * 2 - 1);
                    pointerTarget.set(x, y);
                }
            }, {passive: true});

            animate();
        }

        if (document.readyState === 'loading') {
            document.addEventListener("DOMContentLoaded", initBackground);
        } else {
            initBackground();
        }
    })();
  </script>

    <script>
        document.getElementById("sendResetBtn").addEventListener("click", async () => {
            const email = document.getElementById("resetEmail").value.trim();
            if (!email) return alert("Please enter your email");

            const btn = document.getElementById("sendResetBtn");
            btn.disabled = true;
            btn.textContent = "Sending...";
            const { error } = await supabaseClient.auth.resetPasswordForEmail(email, {
                redirectTo: window.location.origin + '/reset-password',
            });

            if (error) {
                alert("❌ " + error.message);
                btn.disabled = false;
                btn.textContent = "Send Reset Link";
            } else {
                alert("✅ Email sent! Check your inbox for the reset link.");
                btn.textContent = "Email Sent";
            }
        });
    </script>
</body>
</html>
